In the data-rich world we live in, images represent a significant subset of all
measurements made.  Examples include DNA microarrays, microscopy slides,
telescopic observations, satellite maps, robotic vision capture and synthetic
aperture radar images.

To explore this rich data source and to fully understand and interpret its
meaning requires sophisticated software tools--tools that, for reasons
motivated below, should be easy to use, free of charge and restrictions and
able to address the challenges posed by such a diverse field of analysis.

With the rising popularity of Python as a scientific programming language
[citation?] as well as the increasing availability of a large eco-system of
complementary tools, it seems like the ideal environment in which to produce
an image processing toolkit.

This paper describes scikit-image, a collection of image processing algorithms
implemented in the Python programming language by an active community of
volunteers and available under a liberal Open Source license.

The project aims are:

1. To provide high quality, well-documented and cleanly interfaced
   implementations of common image processing algorithms.

   Such algorithms are an essential building block in reproducible scientific
   research, algorithmic comparisons and data exploration.  Especially in the
   context of reproducible science, it is important to be able to inspect any
   source code used for algorithmic flaws or mistakes.

2. To facilitate education in image processing.

   The library allows students in image processing to learn algorithms in a
   hands-on-fashion by adjusting parameters and modifying code.  In addition, a
   ``novice`` module is provided, not only for teaching programming in the
   "turtle graphics" paradigm, but also to familiarize users with image
   concepts such as color, dimensionality, etc.  The project often takes part
   in the yearly Google Summer of Code [gsoc]_ program, where students get to
   learn about image processing and software engineering through implementing
   new features themselves.

3. To address industry challenges.

   High quality reference implementations of trusted algorithms provide
   industry with a reliable way of attacking problems, without having to expend
   significant energy in re-implementing algorithms already available in
   commercial packages.  Companies may use the library entirely free of charge,
   and have the option of contributing changes back, should they so wish.


Getting started
===============


.. figure:: getting_started.png

    Illustration of several functions available in scikit-image: adaptive threshold,
    local maxima, edge detection and labels. :label:`gettingstarted`


We first import the NumPy and matplotlib libraries for array manipulation and
plotting, respectively. At each step, we add the picture or the plot to a
matplotlib figure shown in Figure :ref:`gettingstarted`.  For this
demonstration, we load ``data.coins``, an example image shipped with
scikit-image.

.. code-block:: python

    import numpy as np
    import matplotlib.pyplot as plt

    # Load picture.
    from skimage import data
    image = data.coins()[0:95, 70:370]

    fig, ax = plt.subplots(ncols=2, nrows=3,
                           figsize=(8, 4))
    ax[0, 0].imshow(image, cmap=plt.cm.gray)
    ax[0, 0].set_title('Original', fontsize=24)
    ax[0, 0].axis('off')


Since the image is represented by a Numpy array, we can easily compute
operations like building an histogram of the intensity values.

.. code-block:: python

    # Histogram.
    values, bins = np.histogram(image,
                                bins=np.arange(256))

    ax[0, 1].plot(bins[:-1], values)
    ax[0, 1].set_xlim(xmax=256)
    ax[0, 1].set_title('Histogram', fontsize=24)


Thresholding divides an image into foreground and background. This is often
referred as a binary image.  Several threshold algorithm are available. Here, we
employ ``filter.threshold_adaptive`` where the threshold value is the weighted
mean for the local neighborhood of a pixel.

.. code-block:: python

    # Apply threshold.
    from skimage.filter import threshold_adaptive

    bw = threshold_adaptive(image, 95, offset=-15)

    ax[1, 0].imshow(bw, cmap=plt.cm.gray)
    ax[1, 0].set_title('Adaptive threshold', fontsize=24)
    ax[1, 0].axis('off')

The function ``feature.peak_local_max`` can be used to return the coordinates of
local maxima in an image.

.. code-block:: python

    # Find maxima.
    from skimage.feature import peak_local_max

    coordinates = peak_local_max(image, min_distance=20)

    ax[1, 1].imshow(image, cmap=plt.cm.gray)
    ax[1, 1].autoscale(False)
    ax[1, 1].plot(coordinates[:, 1],
                  coordinates[:, 0], 'r.')
    ax[1, 1].set_title('Peak local maxima', fontsize=24)
    ax[1, 1].axis('off')

A Canny filter (``filter.canny``) [Canny]_ detects the edge of each coin.

.. code-block:: python

    # Detect edges.
    from skimage import filter

    edges = filter.canny(image, sigma=3,
                         low_threshold=10,
                         high_threshold=80)

    ax[2, 0].imshow(edges, cmap=plt.cm.gray)
    ax[2, 0].set_title('Edges', fontsize=24)
    ax[2, 0].axis('off')


Then, we attribute to each coin a label (``morphology.label``) that can be use
to extract a sub-picture and, though ``measure.regionprops``, physical
information such as the position, area, eccentricity, perimeter, and moments,
among others.

.. code-block:: python

    # Label image regions.
    from skimage.measure import regionprops
    import matplotlib.patches as mpatches
    from skimage.morphology import label

    label_image = label(edges)

    ax[2, 1].imshow(image, cmap=plt.cm.gray)
    ax[2, 1].set_title('Labeled items', fontsize=24)
    ax[2, 1].axis('off')

    for region in regionprops(label_image):
        # Draw rectangle around segmented coins.
        minr, minc, maxr, maxc = region.bbox
        rect = mpatches.Rectangle((minc, minr),
                                  maxc - minc,
                                  maxr - minr,
                                  fill=False,
                                  edgecolor='red',
                                  linewidth=2)
        ax[2, 1].add_patch(rect)

    plt.tight_layout()
    plt.show()


Content
=======

The scikit-image project started in August of 2009 and has received
contributions from more than 100 individuals [ohloh]_.  The package can be
installed from, amongst other sources, the Python Package Index, Continuum
Anaconda [anaconda]_, Enthought Canopy [canopy]_, Python(x,y) [pythonxy]_,
NeuroDebian [neurodebian]_ and GNU/Linux distributions such as Ubuntu [ubuntu]_.
In March 2014 alone, the package was downloaded more than 5000 times from the
Python Package Index [pypi]_.

The package currently
contains the following sub-modules:

- color: Color space conversion.
- data: Test images and example data.
- draw: Drawing primitives (lines, text, etc.) that operate on NumPy arrays.
- exposure:  Image intensity adjustment (e.g., histogram equalization).
- feature: Feature detection and extraction (e.g., texture analysis, corners, etc.).
- filter: Sharpening, edge finding, rank filters, thresholding, etc.
- graph: Graph-theoretic operations, e.g., dynamic programming (shortest paths).
- io: Reading, saving, and displaying images and video.
- measure: Measurement of image properties, e.g., similarity and contours.
- morphology: Morphological operations, e.g., opening or skeletonization.
- novice: Simplified interface for teaching purposes.
- restoration: Restoration algorithms, e.g., deconvolution algorithms, denoising, etc.
- segmentation: Partitioning an image into multiple regions.
- transform: Geometric and other transforms, e.g., rotation or the Radon transform.
- viewer: A simple graphical user interface for visualizing results and exploring parameters.

Data format
===========

scikit-image uses NumPy arrays [numpy]_ to represent images.  Each array has a
shape, e.g., ``(M, N)`` for grey-level images, ``(M, N, P)`` for multi-channel
images, or ``(M, N, P, Q)`` for temporal and other multi-dimensional data.  In
addition, it has a data-type such as ``float`` or ``uint8``, that describes the
numerical type of the elements stored.  Since NumPy arrays are a standard
representation for homogeneous data in Python, data can be passed along as-is
to most other tools such as NumPy, SciPy, matplotlib, [scikit-learn]_, OpenCV,
etc.

An image collection class (see `skimage.io.ImageCollection`) is provided for
loading multiple images, also from different directories.  For automatic
visualization in the IPython notebook [ipython]_, lightweight wrapper classes
are provided (see `skimage.io.Image`).

Pipelining
==========

Images of differing data-types can complicate the construction of pipelines.
scikit-image follows an "Anything In, Anything Out" approach, whereby all
functions are expected to allow input of an arbitrary data-type but, for
efficiency, also get to choose their own output format.  Utility functions like
`img_as_float` provide an easy way of converting between image data-types.  The
most common image representation is in floating-point format (data-type
`float`), with values between 0 and 1 (unsigned image) or -1 and 1 (signed
image).


.. [ohloh] Scikit-image on Ohloh, https://www.ohloh.net/p/scikit-image
.. [numpy] S van der Walt, CS Colbert, G Varoquaux. "The NumPy array: a
   structure for efficient numerical computation", Computing in
   Science & Engineering 13 (2), 22-30.
.. [ipython] Fernando PÃ©rez, Brian E. Granger, IPython: A System for
   Interactive Scientific Computing, Computing in Science and Engineering,
   vol. 9, no. 3, pp. 21-29, May/June 2007, doi:10.1109/MCSE.2007.53. URL:
   http://ipython.org
.. [scikit-learn] Pedregosa et al., "Scikit-learn: Machine Learning in
   Python", JMLR 12, pp. 2825-2830, 2011.
.. [pypi] scikit-image 0.9.3 at the Python Package Index.
   https://pypi.python.org/pypi/scikit-image
.. [anaconda] The Anaconda Scientific Python Distribution.
   https://store.continuum.io/cshop/anaconda/
.. [canopy] Enthought Canopy.
   https://www.enthought.com/products/canopy/
.. [pythonxy] Python(x,y). https://code.google.com/p/pythonxy/
.. [neurodebian] python-skimage at NeuroDebian.
   http://neuro.debian.net/pkgs/python-skimage.html
.. [ubuntu] python-skimage in Ubuntu.
   http://packages.ubuntu.com/search?keywords=python-skimage
.. [gsoc] Google Summer of Code.
   https://developers.google.com/open-source/soc
.. [Canny] Canny, J., A Computational Approach To Edge Detection, IEEE Trans.
    Pattern Analysis and Machine Intelligence, 8:679-714, 1986
